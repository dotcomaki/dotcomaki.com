<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Akif</title>
    <style>
        body {
            background-color: black;
            color: #00FF00;
            font-family: monospace;
            font-size: larger;
            margin: 0 auto;
            text-align: center;
            flex-direction: column;
            max-width: 70ch;
            padding-top: 100px;
            align-content: center;
            padding-left: 20px;
            padding-right: 20px;
        }
        a {
            color: white;
            text-decoration: none;
        }
        a:visited {
            color: white;
        }
        p {
            margin-bottom: 40px; 
        }
    </style>
</head>
<body>
    <p><span class="scramble">Hey, my name's Akif. I'm 20 and I'm bored of flashy websites everyone seems to have these days. Here's all the information you need about me in a simple manner.</span></p>

    <p><span class="scramble">You can reach out to me via <a href="mailto:dotcomakif@gmail.com" target="_blank">mail@dotcomaki.com</a> or just shoot me a text @ 'dotcomaki' on any platform.</span></p>

    <p><span class="scramble">Here's my <a href="http://github.com/dotcomaki" target="_blank">Github</a> where I occasionally do some projects and
      here's my <a href="profile.pdf" target="_blank">resume</a> for people who like to look at me from the pov of an ATS screener.</span></p>

    <p><span class="scramble">Oh, almost forgot to link my <a href="http://linkedin.com/in/dotcomaki/" target="_blank">LinkedIn</a>. Connections! Am I right--?<br>
      My tech stack in short is fullstack development, cloud services, AI and devops. I can also help set up and manage your day-to-day operations in addition to development.</span></p>
      
    <p><span class="scramble">I am currently a junior/pre-final year at IIT Madras and the Program Lead of <a href="https://labs.codeday.org" target="_blank">CodeDay Labs</a>.
      I also host <a href="http://instagram.com/codeday_lucknow" target="_blank">CodeDay Lucknow</a> annually, the best hackathon in town.</span></p>

    <p><span class="scramble">Okay, enough work talk. Here's some fun stuff about me. 
      I used to make <a href="https://open.spotify.com/artist/0I5glCgpgTjz3bmINHyo7k?si=8kxOAZkHQRaqCvIb5mmSOQ" target="_blank">music</a> a while ago 
      and I also write a <a href="http://dotcomaki.substack.com" target="_blank">blog</a> about music and other popular media. 
        Here's my <a href="http://letterboxd.com/dotcomaki/" target="_blank">Letterboxd</a> too where I occasionally review films. I love to watch motorsports and sitcoms.</span></p>

    <p><span class="scramble">That's pretty much it! Thank you for visiting my digital abode :D</span></p>
  <script>
    // Continuous word-level scramble and sequential line reveal
    (function(){
      const CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';

      function isTagStart(text, i) { return text[i] === '<'; }
      function isEntityStart(text, i) { return text[i] === '&'; }

      function takeUntil(text, i, endChar) {
        let out = '';
        while (i < text.length && text[i] !== endChar) {
          out += text[i++];
        }
        if (i < text.length) out += text[i];
        return { chunk: out, newIndex: i };
      }

      // Tokenize HTML into tags/entities/words/spaces
      function tokenizeHTML(html) {
        const tokens = [];
        for (let i = 0; i < html.length; i++) {
          if (isTagStart(html, i)) {
            const taken = takeUntil(html, i, '>');
            tokens.push({ type: 'tag', text: taken.chunk });
            i = taken.newIndex;
          } else if (isEntityStart(html, i)) {
            const taken = takeUntil(html, i, ';');
            tokens.push({ type: 'entity', text: taken.chunk });
            i = taken.newIndex;
          } else if (/\s/.test(html[i])) {
            // collect run of whitespace
            let start = i;
            while (i < html.length && /\s/.test(html[i])) i++;
            tokens.push({ type: 'space', text: html.slice(start, i) });
            i--;
          } else {
            // collect run of non-space, non-tag (a word)
            let start = i;
            while (i < html.length && html[i] !== '<' && html[i] !== '&' && !/\s/.test(html[i])) i++;
            tokens.push({ type: 'word', text: html.slice(start, i) });
            i--;
          }
        }
        return tokens;
      }

      function scrambleWord(word) {
        let out = '';
        for (let i = 0; i < word.length; i++) {
          const ch = word[i];
          if (/\w/.test(ch)) {
            out += CHARSET[Math.floor(Math.random() * CHARSET.length)];
          } else {
            out += ch;
          }
        }
        return out;
      }

      // Build scrambled HTML from tokens, revealing words up to revealAll boolean
      function buildScrambledHTML(tokens) {
        return tokens.map(t => {
          if (t.type === 'tag' || t.type === 'entity' || t.type === 'space') return t.text;
          return scrambleWord(t.text);
        }).join('');
      }

      // Build HTML where we fully reveal (use original) for revealed flag
      function buildMixedHTML(tokens, reveal) {
        // reveal: boolean - if true show original words, else scramble
        return tokens.map(t => {
          if (t.type === 'tag' || t.type === 'entity' || t.type === 'space') return t.text;
          return reveal ? t.text : scrambleWord(t.text);
        }).join('');
      }

      // main
      const elems = Array.from(document.querySelectorAll('.scramble'));
      let perLineMs = 700; // default stagger between lines (ms)
      // attempt to read existing value if user previously set perLineMs in global scope
      try { if (typeof window.scramblePerLineMs === 'number') perLineMs = window.scramblePerLineMs; } catch(e){}

      const scrambleIntervalMs = 60; // how often unrevealed words reshuffle

      const items = elems.map(el => ({ el, original: el.innerHTML, tokens: tokenizeHTML(el.innerHTML), revealed: false }));

      // Start by continuously scrambling all unrevealed elements
      const intervalId = setInterval(() => {
        items.forEach(item => {
          if (!item.revealed) {
            item.el.innerHTML = buildScrambledHTML(item.tokens);
          }
        });
      }, scrambleIntervalMs);

      // Reveal elements sequentially with perLineMs delay; when revealed stop scrambling them
      items.forEach((item, idx) => {
        setTimeout(() => {
          item.revealed = true;
          item.el.innerHTML = item.original;
          // If last item, stop the continuous interval
          if (idx === items.length - 1) clearInterval(intervalId);
        }, idx * perLineMs);
      });
    })();
  </script>
  </script>
</body>
</html>
